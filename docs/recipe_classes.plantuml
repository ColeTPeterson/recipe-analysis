@startuml "Recipe Classes"

' SYMBOL
enum SymbolType {
  ACTION
  EQUIPMENT
  INGREDIENT
  UNIT
}

abstract class Symbol {
  + entity_id: integer
  + type: SymbolType
  + name: string
  + canonical_form: (integer, string) [0..1]
  + identities: Set<string>
  + properties: Map<string, Any>
  + description: string
}
note right of Symbol
  Represents a recognized term (action, equipment, ingredient, etc.) used as
  a **Symbolic Descriptor**. Each Symbol has one 'type' (SymbolType).
  'name' is the instance name, 'canonical_form' is used for hierarchy.
  'identities' stores hierarchical category paths from *_canonical tables.
  'properties' stores key-value pairs from *_properties tables.
  Canonical symbols have canonical_form=None.
  Alias symbols have canonical_form=(canonical_id, canonical_name).
  Instances are typically obtained from a central registry/lookup.
end note

Symbol <|-- Action
Symbol <|-- Item
Symbol <|-- Unit

Symbol ..> SymbolType


' SYMBOL > ACTION
enum ActionIdentity {
  COMBINATION
  COOKING_METHOD
  DIVISION         // reversible     e.g. half     (dough(100%) -> dough (50%), dough (50%))
  PREPARATION 
  SEPARATION       // non-reversible e.g. separate (egg -> yolks + whites)
  TEMPERATURE_CHANGE
  TEMPERATURE_CHANGE_DECREASE
  TEMPERATURE_CHANGE_INCREASE
  ...
} 

enum ActionArity {
  UNARY
  BINARY
  TERNARY
  N_ARY
  SPLITTING
  VARIABLE
}
note right of ActionArity
  Defines input/output behavior for action symbols:
  - UNARY:      1 input → 1 output (e.g., chop, heat)
  - BINARY:     2 inputs → 1 output (e.g., mix, combine)
  - TERNARY:    3 inputs → 1 output (e.g., complex combinations)
  - N_ARY:      n inputs → 1 output (e.g., assemble)
  - SPLITTING:  1 input → n outputs (e.g., separate, divide)
  - VARIABLE:   n inputs → n outputs
end note

class Action {
  - arity: ActionArity [0..1]
}

Action ..> ActionIdentity : identities
Action ..> ActionArity

' SYMBOL > ITEM
enum ItemPropertyKey {
  COLOR
  PREPARATION_STYLE // general prep e.g. washed, heated, covered, ...
  SIZE_ABSOLUTE
  SIZE_RELATIVE
  ...
}

abstract class Item {
  - dimensions: Dimensions
}
note right of Item
  Adds physical attributes specific to recipe components.
end note


Item <|-- Ingredient
Item <|-- Equipment
Item ..> ItemPropertyKey

Item o-- "0..1" Dimensions : dimensions


' SYMBOL > ITEM > EQUIPMENT
enum EquipmentIdentity {
  APPLIANCE_LARGE
  APPLIANCE_SMALL
  TOOL_CUTTING    // e.g. knife, peeler, ...
  TOOL_MEASURING
  TOOL_MEASURING_VOLUME
  TOOL_MEASURING_VOLUME_DRY    // e.g. measuring scoop
  TOOL_MEASURING_VOLUME_LIQUID // e.g. measuring cup
  TOOL_MEASURING_WEIGHT
  TOOL_MIXING     // e.g. whisk, spoon, ...
  VESSEL
  VESSEL_BAKEWARE // e.g. sheet pan, cake tin, ...
  VESSEL_COOKWARE // e.g. frying pan, saucepan, griddle, ...
  ...
}

enum EquipmentPropertyKey {
  MATERIAL    // e.g. steel, wooden, copper, silicone, ...
}

class Equipment {
  - contents: Set<Ingredient | IntermediateIngredient>
}
note right of Equipment
  'properties' inherited from Item contains states like MATERIAL, etc.
  Equipment with VESSEL identity can store ingredients in 'contents'.
  When multiple ingredients are stored, they can be combined into
  IntermediateIngredients through vessel operations.
end note

Equipment ..> EquipmentIdentity : identities  
Equipment ..> EquipmentPropertyKey : properties


' SYMBOL > ITEM > EQUIPMENT > INTERMEDIATE
Equipment <|-- IntermediateEquipment
class IntermediateEquipment {
  - source_equipment: Set<Equipment>
  - source_ingredients: Set<Ingredient>
}

IntermediateEquipment o-- "1" Instruction : produced_by
IntermediateEquipment o-- "1..*" Equipment : source_equipment
IntermediateEquipment o-- "0..*" Ingredient : source_ingredients


' SYMBOL > ITEM > INGREDIENT
enum IngredientIdentity {
  DAIRY
  DAIRY_CHEESE
  DAIRY_MILK
  DAIRY_MILK_FAT_LOW
  DAIRY_MILK_FAT_REDUCED
  FRUIT
  FRUIT_BERRY
  GRAIN
  GRAIN_CEREAL_RICE
  GRAIN_CEREAL_WHEAT
  HERB
  MEAT
  MEAT_BEEF
  MEAT_BEEF_CUT
  NUT
  SPICE
  VEGETABLE
  VEGETABLE_LEAF
  VEGETABLE_ROOT
  ...
}

enum IngredientPropertyKey {
  CONSISTENCY // e.g. lumpy, crumbly, soft, medium, stiff
  CUT         // e.g. diced, minced, sliced, julienned, ...
  TEXTURE     // e.g. shiny, smooth, ...
  ...
}

class Ingredient {}
note right of Ingredient
  'properties' inherited from Item contains states like CUT, TEXTURE, etc.
end note

Ingredient ..> IngredientIdentity : identities
Ingredient ..> IngredientPropertyKey : properties


' SYMBOL > ITEM > INGREDIENT > INTERMEDIATE
Ingredient <|-- IntermediateIngredient
class IntermediateIngredient {
  - source_ingredients: Set<Ingredient>
}

IntermediateIngredient o-- "1" Instruction : produced_by
IntermediateIngredient o-- "1..*" Ingredient : source_ingredients


' RECIPE
class Recipe {
  - id: integer
  - title: string
  - root_instructions: Set<Instruction>
  - all_instructions: Set<Instruction>
}
note right of Recipe
  == DAG Constraint:
  The Instruction graph must be acyclic
  (no circular dependencies)
end note

Recipe *-- "0..*" Instruction : root_instructions
Recipe o-- "0..*" Instruction : all_instructions  


' INSTRUCTION
class Instruction {
  - id: integer
  - action: Action
  - ingredients: Map<Ingredient, IngredientUsage> [0..*]
  - equipment: Map<Equipment, EquipmentUsage> [0..*]
  - produces: Item
  - temperature: Temperature [0..1]
  - duration: Duration [0..1]
  - prerequisites: Instruction [0..*]
  - next: Instruction [0..*]
}

Instruction o-- "1" Action : action
Instruction --> "0..*" Ingredient : uses_ingredients
Instruction --> "0..*" Equipment : uses_equipment
Instruction o-- "0..*" IngredientUsage : ingredient_usage_details
Instruction o-- "0..*" EquipmentUsage : equipment_usage_details

class IngredientUsage <<dataclass>> {
  + count: integer [0..1]
  + proportion: float [0..1]
  + measurement: Measurement
}
IngredientUsage o-- "0..1" Measurement : measurement

class EquipmentUsage <<dataclass>> {
  + count: integer [0..1]
}


Instruction --> "0..1" Item : produces
Instruction o-- "0..1" Temperature : temperature
Instruction o-- "0..1" Duration : duration


' Unit
enum UnitIdentity {
  LENGTH
  MASS
  TEMPERATURE
  TEMPERATURE_ABSOLUTE
  TEMPERATURE_RELATIVE
  TIME
  TIME_ABSOLUTE
  TIME_RELATIVE
  VOLUME
  ...
}

enum UnitPropertyKey {
  LEVEL
}

class Unit {}

Unit ..> UnitIdentity : identities  
Unit ..> UnitPropertyKey : properties


' MEASUREMENT
abstract class Quantification {
  + unit: Optional[Symbol]
  + get_unit(): Optional[Symbol]
}
note right of Quantification
  Base class for all measurements in recipes.
  All quantifications have at minimum a unit
  (which may be optional in some cases).
end note

abstract class Measurement extends Quantification {}
Measurement <|-- MeasurementAbs : {disjoint, complete}
Measurement <|-- MeasurementRel : {disjoint, complete}


' MEASUREMENT > ABSOLUTE
class MeasurementAbs <<dataclass>> {
  + value: float [0..1]
}
note right of MeasurementAbs::unit
  Symbol.identities from UnitIdentity (TEMPERATURE).
end note


' MEASUREMENT > RELATIVE
class MeasurementRel <<dataclass>> {
  + value_min: float [0..1]
  + value_max: float [0..1]
}
note left of MeasurementRel::unit
  Symbol.identities from UnitIdentity.
end note


' TEMPERATURE
abstract class Temperature extends Quantification {}
note right of Temperature
  == Temperature Constraints:
  One of the following must be true:
    1. value and unit exist (TemperatureAbs)
    2. value_min, value_max, and unit exist (TemperatureRel)
    3. only level exists (TemperatureRel)
end note

Temperature <|-- TemperatureAbs : {disjoint, complete}
Temperature <|-- TemperatureRel : {disjoint, complete}


' TEMPERATURE > ABSOLUTE
class TemperatureAbs <<dataclass>> {
  + value: float
}
note left of TemperatureAbs::unit
  Symbol.identities from UnitIdentity (TEMPERATURE).
end note


' TEMPERATURE > RELATIVE
class TemperatureRel <<dataclass>> {
  + value_min: float [0..1]
  + value_max: float [0..1]
  + level: string [0..1]
}
note right of TemperatureRel::unit
  Symbol.identities from UnitIdentity (TEMPERATURE).
end note
note right of TemperatureRel::level
  Text-based temperature levels like "low", 
  "medium", "high", etc.
end note


' DURATION
abstract class Duration extends Quantification {}
note right of Duration
  == Duration Constraints:
  One of the following must be true:
    1. value and unit exist (DurationAbs)
    2. value_min, value_max, and unit exist (DurationRel)
end note

Duration <|-- DurationAbs : {disjoint, complete}
Duration <|-- DurationRel : {disjoint, complete}


' DURATION > ABSOLUTE
class DurationAbs <<dataclass>> {
  + value: float
}
note left of DurationAbs::unit
  Symbol.identities from UnitIdentity (TIME).
end note


' DURATION > RELATIVE
class DurationRel <<dataclass>> {
  + value_min: float
  + value_max: float
}
note right of DurationRel::unit
  Symbol.identities from UnitIdentity (TIME).
end note


' DIMENSIONS
abstract class Dimensions extends Quantification {}
note left of Dimensions
  == Dimensions Constraints:
  One of the following must be true:
    1. values and unit exist (DimensionsAbs)
      - Represents exact dimensions (e.g. "9 in." or "13x9 in.")
    2. values_min, values_max, and unit exist (DimensionsRel)
      - Represents dimension ranges (e.g. "8-9 in." or "10-12 x 8-9 in.")
end note

Dimensions <|-- DimensionsAbs : {disjoint, complete}
Dimensions <|-- DimensionsRel : {disjoint, complete}


' DIMENSIONS > ABSOLUTE
class DimensionsAbs <<dataclass>> {
  + values: float [1..3]
}
note right of DimensionsAbs::unit
  Symbol.identities from UnitIdentity (LENGTH).
end note


' DIMENSIONS > RELATIVE
class DimensionsRel <<dataclass>> {
  + values_min: float[1..3]
  + values_max: float[1..3]
}
note left of DimensionsRel::unit
  Symbol.identities from UnitIdentity (specifically LENGTH).
end note

@enduml